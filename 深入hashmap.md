# 常见的哈希算法与碰撞算法

## 哈希算法

- 直接定址法：直接以关键字k或者k加上某个常数（k+c）作为哈希地址。
- 数字分析法：提取关键字中取值比较均匀的数字作为哈希地址。
- 除留余数法：用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址。
- 分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。
- 平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。
- 伪随机数法：采用一个伪随机数当作哈希函数



## 解决碰撞算法

- 开放定址法

- - 开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。

- 链地址法

- - 将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。

- 再哈希法

- - 当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。

- 建立公共溢出区

- - 将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。

# HASHMAP(JDK1.7)最详细原理分析（一）

在JDK1.7中，HASHMAP是由数组+链表实现的，原理图如下：

![image](https://cdn.nlark.com/yuque/0/2019/png/365147/1559393079633-f01038db-0d1b-420d-a9f3-2c238e39c71f.png)



```
HashMap map = new HashMap(); // 伪初始化
map.put("键"，"值"); // 真初始化
```



HashMap的构造方法在执行时会初始化一个数组table，大小为0。

HashMap的PUT方法在执行时首先会判断table的大小是否为0，如果为0则会进行真初始化，也叫做延迟初始化。

当进行真初始化时，数组的默认大小为16，当然也可以调用HASHMAP的有参构造方法由你来指定一个数组的初始化容量，但是注意，并不是你真正说了算，比如你现在想让数组的初始化容量为6，那么HASHMAP会生成一个大小为8的数组，如果你想数组的初始化容量为20，那么HASHMAP会生成一个大小为32的数组，也就是你想初始化一个大小为n的数组，但是HASHMAP会初始化一个大小**大于等于n的二次方数**的一个数组。至于为什么要这样，我们等会再说。



对于PUT方法，当无需对table进行初始化或已经初始化完了之后，它接下来的主要任务是将key和value存到数组或链表中。**那么怎么将一个keyvalue给存到数组中去呢？**

我们知道，如果我们想往数组中存入数据，我们首先得有一个数组下标，而我们在进行PUT的时候并不需要再传一个参数来作为数组的下标，那么HASHMAP中下标是怎么获取来的呢？答案为哈希算法，这也是为什么叫HASHMAP而不叫其他MAP。



对于哈希算法，了解过的人应该都知道它需要一个哈希函数，这个函数接收一个参数返回一个HashCode，哈希函数的特点是对于相同的参数那么返回的HashCode肯定是相同的，对于不相同的参数，函数会尽可能的去返回不相同的HashCode，所以换一个角度理解，对于哈希函数，给不相同的参数可能会返回相同的HashCode，这个就叫哈希冲突或哈希碰撞。



那么我们能直接把这个HashCode来作为数组下标吗，另外一个很重要的问题是**我们到底应该对** **key**做哈希运算还是对**value**做哈希运算，还是对**keyvalue**同时做哈希运算？



那么这个时候我们就要考虑到GET方法了，因为GET只需要传入一个key作为参数，而实际上GET方法的逻辑就是通过把key进行哈希运算快速的得到数组下标，从而快速的找到key所对应的value。**所以对于PUT方法虽然传入了两个参数，但是只能对key进行哈希运算得到数组下标，这样才能方便GET方法快速查找。**



**但是还有一个问题就是，HashCode它能直接作为数组下标吗？**

HashCode它通常是一个比较大的数字，比如：

```
System.out.println("键".hashCode()); // 38190
// 为什么是这个结果，大家自行去看String类中的hashCode方法
```

所以我们不可能把这么大的一个数字作为数组下标，那怎么办？

大家可能通常会想到取模运算，但是HashMap没有用取模，而是：



```
static int indexFor(int h, int length) {
    // assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";
    return h & (length-1);
}
```

这个方法就是JDK1.7HashMap中PUT和GET方法中获取数组下标的方法（PUT和GET两个方法都要去获取下标？是的，如果你看到这里看不懂了，那么你再去想想上面的讲的提高GET方法效率的逻辑吧），这个方法中h代表hashcode，length代表数组长度。我们发现它是用的**逻辑与**操作，那么问题就来了，逻辑与操作能准确的算出来一个数组下标？我们来算算，假设hashcode是01010101(二进制表示)，length为00010000(16的二进制表示)，那么h & (length-1)则为：

```
h:  0101 0101
15: 0000 1111
  &
    0000 0101
```

对于上面这个运行结果的取值方法我们来讨论一下：因为15的高四位都是0，低四位都是1，而与操作的逻辑是两个运算位都为1结果才为1，所以对于上面这个运算结果的高四位肯定都是0，而低四位和h的低四位是一样的，所以结果的取值范围就是h的低四位的一个取值范围：0000-1111，也就是0至15，所以这个结果是符合数组下标的取值范围的。

那么假设length为17呢？那么h & (length-1)则为：



```
h:  0101 0101
16: 0001 0000
  &
    0001 0000
```

当length为17时，上面的运算的结果取值范围只有两个值，要么是0000 0000，要么是0001 000，这是不太好的。



所以我们发现，如果我们想把HashCode转换为覆盖数组下标取值范围的下标，跟我们的length是非常相关的，length如果是16，那么减一之后就是15(0000 1111)，正是这种高位都为0，低位都为1的二级制数才保证了可以对任意一个hashcode经过逻辑与操作后得到的结果是我们想要的数组下标。**这就是为什么在真初始化HashMap的时候，对于数组的长度一定要是二次方数，二次方数和算数组下标是息息相关的，而这种位运算是要比取模更快的。**

**
**

所以到此我们可以理一下：在调用PUT方法时，会对传入的key进行哈希运算得到一个hashcode，然后再通过逻辑与操作得到一个数组下标，最后将keyvalue存在这个数组下标处。



确定了keyvalue该存的位置之后，上文说过，对于不同的参数可能会得到相同的HashCode，也就是会发生哈希冲突，反应到HashMap中就是，当PUT两个不同的key时可能会得到相同的HashCode从而得到相同的数组下标，其实在HashMap中就算key所对应的HashCode不一样，那么也有可能在经过逻辑与操作之后得到相同的数组下标，那么这时HashMap是如何处理的呢？对，是链表，具体是怎么实现的呢？下篇文章继续吧。

# HASHMAP(JDK1.7)最详细原理分析（二）

昨天的博客我解释了HASHMAP(JDK1.7)在PUT的时候会发生冲突，而解决冲突的方式就是使用链表，那么我们假设HASHMAP存储结构如下图：

![image.png](https://cdn.nlark.com/yuque/0/2019/png/365147/1559539766929-fa3be7f9-072a-46e9-b0f4-d7e922b43bef.png)

那么节点1和节点2组成了一个链表，那么现在如果再来PUT一个节点3，假设节点3也需要插在这个链表中，我们考虑链表的插入效率，将节点3插在链表的头部是最快的，那么就会如下图：

![image.png](https://cdn.nlark.com/yuque/0/2019/png/365147/1559539733346-e2fdebef-8aa2-4657-b1c7-73700ceb21a8.png)

那么按照上图这种插入办法，会出现一个问题：

- 当我们需要get(节点2)时，我们先将节点2的key进行哈希然后算出下标，拿到下标后可以定位到数组中的节点1，但是发现节点1不等于节点2，所以不是最终的结果，但是节点1存在下一个节点，所以可以顺着向下的指针找到节点2。
- 那么当我们需要get(节点3)时呢，我们发现是找不到节点3的，**所以当我们把节点简单的插在链表的头部是不行的。**

那HashMap是怎么实现的呢？HashMap确实是将节点插在链表的头部，但是在插完之后HashMap会将整个链表向下移动一位，移动完之后就会变成：

![image.png](https://cdn.nlark.com/yuque/0/2019/png/365147/1559540332883-f7792773-13cb-4e27-ada2-fcbc14ed86bf.png)

那么现在PUT的时候插入一个元素的思路就是：**将新节点插在链表的头部，此时新节点就是当前这个链表的头节点，接下来把头节点移动到数组位置即可。**



当我们在使用HashMap的时候，还可能会出现下面的使用方式:



```
HashMap<String, String> hashMap = new HashMap<>();
hashMap.put("1", "2");
String value = hashMap.put("1", "3");
System.out.println(value);
```

第三行代码也是PUT，而这个时候在HashMap里会将value覆盖，也就是key="1"对应的value最终为"3"，而第三行代码返回的value将会是2。

我们现在来考虑这个PUT它是如何实现的，其实很简单，第三行代码的逻辑也是先对"1"计算哈希值以及对应的数组下标，有了数组下标之后就可以找到对应的位置的链表，而在将新节点插入到链表之前，还需要判断一下当前新节点的key值是不是已经在这个链表上存在，所以需要先去遍历当前这个位置的链表，在遍历的过程中如果找到了相同的key则会进行value的覆盖，并且返回oldvalue。



好，写到这里其实对于HashMap的PUT的主要逻辑也差不多了，总结一下：

1. PUT(key，value)
2. int hashcode = key.hashCode();
3. int index = hashcode & (数组长度-1)
4. 遍历index位置的链表，如果存在相同的key，则进行value覆盖，并且返回之前的value值
5. 将key，value封装为节点对象（Entry）
6. 将节点插在index位置上的链表的头部
7. 将链表头节点移动到数组上

这是最核心的7步，然后在这个过程中还有很重要的一步就是**扩容**，而扩容是发生在插入节点之前的，也就是步骤4和5之间的。

那么关于JDK1.7里HashMap的扩容时会出现“死锁”问题的，我们下篇文章继续。

# HashMap扩容死循环问题源码分析

[📎HashMap扩容死循环问题源码分析.mp4](https://www.yuque.com/attachments/yuque/0/2019/mp4/365147/1562047370404-d5578799-f81b-43ea-b81c-ba09be1e18df.mp4)