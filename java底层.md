# 一文搞明白位运算、补码、反码、原码

在平时看各种框架的源码的过程中，经常会看到一些位移运算，所以作为一个Java开发者是一定掌握位移运算的。

### 正数位移运算

Java中有三个位移运算：

- `<<：左移`
- `>>：右移`
- `>>>：无符号右移`
  我们直接看一下Demo:

```
System.out.println(2 << 1);     // 4
System.out.println(2 >> 1);     // 1
System.out.println(2 >>> 1);    // 1
System.out.println(-2 << 1);    // -4
System.out.println(-2 >> 1);    // -1
System.out.println(-2 >>> 1);   // 2147483647
```

乍一眼看到上面Demo的打印结果，你应该是懵逼的，接下来我来解释一下这个结果到底是如何运算出来的。

上面的Demo中有“2”和“-2”，这是两个十进制数，并且是int类型的(java中占四个字节)，位运算是基于二进制bit来的，所以我们需要**将十进制转换为二进制之后再进行运算**：

- `2 << 1`：十进制“2”转换成二进制为“00000000 00000000 00000000 00000010”，再将二进制左移一位，高位丢弃，低位补0，所以结果为“00000000 00000000 00000000 00000100”，换算成十进制则为“4”
- `2 >> 1`：十进制“2”转换成二进制为“00000000 00000000 00000000 00000010”，再将二进制右移一位，低位丢弃，高位补0，所以结果为“00000000 00000000 00000000 00000001”，换算成十进制则为“1”
  对于这两种情况非常好理解，那什么是**无符号右移**，以及负数是怎么运算的呢？
  我们先来看`-2 << 1`与`-2 >> 1`，这两个负数的左移与右移操作其实和正数类似，都是先将十进制数转换成二进制数，再将二进制数进行移动，所以现在的关键是负数如何用二进制数进行表示。

### 原码、反码、补码

接下来我们主要介绍十进制数用二进制表示的不同方法，所以为了简洁，我们用一个字节，也就是8个bit来表示二进制数。

#### 原码

| 十进制 | 原码      |
| ------ | --------- |
| 2      | 0000 0010 |
| -2     | 1000 0010 |

原码其实是最容易理解的，只不过需要利用二进制中的第一位来表示符号位，0表示正数，1表示负数，所以可以看到，一个数字用二进制原码表示的话，取值范围是`-111 1111 ~ +111 1111`，换成十进制就是`-127 ~ 127`。

#### 反码

在数学中我们有加减乘除，而对于计算机来说最好只有加法，这样计算机会更加简单高效，我们知道在数学中`5-3=2`，其实可以转换成`5+(-3)=2`，这就表示减法可以用加法表示，而乘法是加法的累积，除法是减法的累积，所以在计算机中只要有加法就够了。

一个数字用原码表示是容易理解的，但是需要单独的一个bit来表示符号位。并且在进行加法时，计算机需要先识别某个二进制原码是正数还是负数，识别出来之后再进行相应的运算。这样效率不高，能不能让计算机在进行运算时不用去管符号位，也就是说让符号位也参与运算，这就要用到反码。

| 十进制 | 原码      | 反码      |
| ------ | --------- | --------- |
| 2      | 0000 0010 | 0000 0010 |
| -2     | 1000 0010 | 1111 1101 |

正数的反码和原码一样，负数的反码就是在原码的基础上符号位保持不变，其他位取反。

那么我们来看一下，用反码直接运算会是什么情况，我们以`5-3`举例。

```
5 - 3` 等于 `5 + (-3)
```

| 十进制 | 原码      | 反码      |
| ------ | --------- | --------- |
| 5      | 0000 0101 | 0000 0101 |
| -3     | 1000 0011 | 1111 1100 |



```
5-3
= 5+(-3)
= 0000 0101(反码) + 1111 1100(反码) 
= 0000 0001(反码)
= 0000 0001(原码) 
= 1
```

这不对呀?!! 5-3=1?，为什么差了1？

我们来看一个特殊的运算：

```
1-1
= 1+(-1)
= 0000 0001(反码) + 1111 1110(反码)
= 1111 1111(反码)
= 1000 0000(原码)
= -0
```

我们来看一个特殊的运算：

```
0+0
= 0000 0000(反码) + 0000 0000(反码)
= 0000 0000(反码)
= 0000 0000(原码)
= 0
```

我们可以看到1000 0000表示-0，0000 0000表示0，虽然-0和0是一样的，但是在用原码和反码表示时是不同的，我们可以理解为在用一个字节表示数字取值范围时，这些数字中多了一个-0，所以导致我们在用反码直接运算时符号位可以直接参加运算，但是结果会不对。

#### 补码

为了解决反码的问题就出现了补码。

| 十进制 | 原码      | 反码      | 补码      |
| ------ | --------- | --------- | --------- |
| 2      | 0000 0010 | 0000 0010 | 0000 0010 |
| -2     | 1000 0010 | 1111 1101 | 1111 1110 |

正数的补码和原码、反码一样，负数的补码就是反码+1。

| 十进制 | 原码      | 反码      | 补码      |
| ------ | --------- | --------- | --------- |
| 5      | 0000 0101 | 0000 0101 | 0000 0101 |
| -3     | 1000 0011 | 1111 1100 | 1111 1101 |

```
5-3
= 5+(-3)
= 0000 0101(补码) + 1111 1101(补码)
= 0000 0010(补码)
= 0000 0010(原码) 
= 2
```

5-3=2！！正确。

再来看特殊的：

```
1-1
= 1+(-1)
= 0000 0001(补码) + 1111 1111(补码)
= 0000 0000(补码)
= 0000 0000(原码)
= 0
```



1-1=0！！正确

再来看一个特殊的运算：



```
0+0
= 0000 0000(补码) + 0000 0000(补码)
= 0000 0000(补码)
= 0000 0000(原码)
= 0
```



0+0=0！！也正确。

所以，我们可以看到补码解决了反码的问题。

所以对于数字，我们可以使用补码的形式来进行二进制表示。



### 负数位移运算



我们再来看`-2 << 1`与`-2 >> 1`。

-2用原码表示为`10000000 00000000 00000000 00000010`

-2用反码表示为`11111111 11111111 11111111 11111101`

-2用补码表示为`11111111 11111111 11111111 11111110`

`-2 << 1`，表示-2的补码左移一位后为`11111111 11111111 11111111 11111100`，该补码对应的反码为



```
11111111 11111111 11111111 11111100
- 1
= 11111111 11111111 11111111 11111011
```



该反码对应的原码为：符号位不变，其他位取反，为`10000000 00000000 00000000 00000100`，表示-4。

所以`-2 << 1 = -4`。

同理`-2 >> 1`是一样的计算方法，这里就不演示了。



### 无符号右移



上面在进行左移和右移时，我有一点没讲到，就是在对补码进行移动时，符号位是固定不动的，而无符号右移是指在进行移动时，**符号位也会跟着一起移动**。

比如`-2 >>> 1`。

-2用原码表示为`10000000 00000000 00000000 00000010`

-2用反码表示为`11111111 11111111 11111111 11111101`

-2用补码表示为`11111111 11111111 11111111 11111110`

-2的补码右移1位为：`01111111 11111111 11111111 11111111`

右移后的补码对应的反码、原码为：`01111111 11111111 11111111 11111111` （因为现在的符号位为0，表示正数，正数的原、反、补码都相同）

所以，对应的十进制为2147483647。

也就是`-2 >>> 1 = 2147483647`



### 总结



文章写的可能比较乱，希望大家能看懂，能有所收获。这里总结一下，我们可以发现：

2 << 1 = 4 = 2*2

2 << 2 = 8 = 2*2*2

2 << n = 2*2n

m << n = m * 2n

右移则相反，所以大家以后在源码中再看到位运算时，可以参考上面的公式

# Integer.highestOneBit(int i)方法的作用与底层实现

在Integer类中有这么一个方法，你可以给它传入一个数字，它将返回最大的小于等于这个数字的一个2的幂次方数。这个方法就是highestOneBit(int i)。



比如下面的Demo，注意方法的输入与返回值：

```
System.out.println(Integer.highestOneBit(15));  // 输出8
System.out.println(Integer.highestOneBit(16));  // 输出16
System.out.println(Integer.highestOneBit(17));  // 输出16
```





这个方法的实现代码量也是非常少的：

```
public static int highestOneBit(int i) {
    // HD, Figure 3-1
    i |= (i >>  1);
    i |= (i >>  2);
    i |= (i >>  4);
    i |= (i >>  8);
    i |= (i >> 16);
    return i - (i >>> 1);
}
```



接下来，我们就来详细分析一下这块代码的逻辑。



首先，对于这个方法的功能：**给定一个数字，找到小于或等于这个数字的一个2的幂次方数。**



如果我们要自己来实现的话，我们需要知道：**怎么判断一个数字是2的幂次方数。**



说真的，我一下想不到什么好方法来判断，唯一能想到的就是一个数字如果把它转换成二进制表示的话，它会有一个规律：**如果一个数字是2的幂次方数，那么它对应的二进制表示仅有一个bit位上是1，其他bit位全为0。**

比如：

十进制6，二进制表示为：0000 0110

十进制8，二进制表示为：0000 1000

十进制9，二进制表示为：0000 1001

所以，我们可以利用一个数字的二进制表示来判断这个数字是不是2的幂次方数。关键代码怎么实现呢？去遍历每个bit位？可以，但是不好，那怎么办？我们还是回头仔细看看Integer是如何实现的吧？



```
public static int highestOneBit(int i) {
    // HD, Figure 3-1
    i |= (i >>  1);
    i |= (i >>  2);
    i |= (i >>  4);
    i |= (i >>  8);
    i |= (i >> 16);
    return i - (i >>> 1);
}
```



我们发现这段代码中没有任何的遍历，只有位运算与一个减法，也就是说它的实现思路和我们自己的实现思路完全不一样，它的思路就是：**给定一个数字，通过一系列的运算，得到一个小于或等于该数字的一个2的幂次方数。**



也就是：如果给定一个数字18，通过运算后，要得到16。

18用二进制表示为：    0001 0010

想要得到的结果(16)是：0001 0000



那么这个运算的过程无非就是**将18对应的二进制数中除最高位的1之外的其他bit位都清零，则拿到了我们想要的结果。**



那怎么通过位运算来实现这个过程呢？



我们拿18对应的二进制数`0001 0010`来举个例子就行了：

先将`0001 0010`右移1位，

得到`0000 1001`，再与自身进行或运算：

得到`0001 1011`。



再将`0001 1011`右移2位，

得到`0000 0110`，再与自身进行或运算：

得到`0001 1111`。



再将`0001 1111`右移4位，

得到`0000 0001`，再与自身进行或运算：

得到`0001 1111`。



再将`0001 1111`右移8位，

得到`0000 0000`，再与自身进行或运算：

得到`0001 1111`。



再将`0001 1111`右移16位，

得到`0000 0000`，再与自身进行或运算：

得到`0001 1111`。



再将`0001 1111`无符号右移1位，

得到`0000 1111`。



> 关于无符号右移，可以看我之前写的文章。



最后用`0001 1111  - 0000 1111 = 0001 0000`

震惊！得到了我们想要的结果。



其实这个过程可以抽象成这样：

现在有一个二进制数据，`0001****`，我们不关心低位的取值情况，我们对其进行右移并且进行或运算。



先将`0001****`右移1位，

得到`00001***`，再与自身进行或运算：

得到`00011***`。



再将`00011***`右移2位，

得到`0000011*`，再与自身进行或运算：

得到`0001111*`。



再将`0001111*`右移4位，

得到`00000001`，再与自身进行或运算：

得到`00011111`。



后面不用再推算了，到这里我们其实可以发现一个规律：

**右移与或运算的目的就是想让某个数字的低位都变为1，再用该结果 减去 该结果右移一位后的结果，则相当于清零了原数字的低位。即得到了我们想要的结果。**

到此，只能感叹JDK作者对于位运算的使用已经达到了出神入化的境界了。

# String.intern()使用总结

## First Blood

先看下面的代码：



```
String s = new String("1");
String s1 = s.intern();
System.out.println(s == s1);
```



```
打印结果为：
false
```



对于`new String("1")`，会生成两个对象，一个是String类型对象，它将存储在**Java Heap**中，另一个是字符串常量对象"1"，它将存储在**字符串常量池**中。

`s.intern()`方法首先会去字符串常量池中查找是否存在字符串常量对象"1"，如果存在则返回该对象的地址，如果不存在则在字符串常量池中生成为一个"1"字符串常量对象，并返回该对象的地址。

如下图：

![image.png](https://cdn.nlark.com/yuque/0/2019/png/365147/1561106205518-114481cd-eec1-48ff-8e83-348e20c020fe.png)

变量`s`指向的是Stirng类型对象，变量`s1`指向的是"1"字符串常量对象，所以`s == s1`结果为false。



## Double kill

在上面的基础上我们再定义一个s2如下：



```
String s = new String("1");
String s1 = s.intern();
String s2 = "1";
System.out.println(s == s1);
System.out.println(s1 == s2); // true
```



`s1 == s2`为true，表示变量s2是直接指向的字符串常量，如下图：

![image.png](https://cdn.nlark.com/yuque/0/2019/png/365147/1561106720355-d53d5a43-6556-4bde-b2fa-26e35f536222.png)



## Triple kill

在上面的基础上我们再定义一个t如下：



```
String s = new String("1");
String t = new String("1");
String s1 = s.intern();
String s2 = "1";
System.out.println(s == s1);
System.out.println(s1 == s2);
System.out.println(s == t);   // false
System.out.println(s.intern() == t.intern());   // true
```



`s == t`为false，这个很明显,变量s和变量t指向的是不同的两个String类型的对象。

`s.intern() == t.intern()`为true，因为intern方法返回的是字符串常量池中的同一个"1"对象，所以为true。



![image.png](https://cdn.nlark.com/yuque/0/2019/png/365147/1561107119102-56e83e3c-0283-4840-968c-dc2c4230e5cb.png)



## Ultra kill

在上面的基础上我们再定义一个x和s3如下：



```
String s = new String("1");
String t = new String("1");
String x = new String("1") + new String("1");
String s1 = s.intern();
String s2 = "1";
String s3 = "11";
System.out.println(s == s1);
System.out.println(s1 == s2);
System.out.println(s == t);
System.out.println(s.intern() == t.intern());
System.out.println(x == s3);  // fasle
System.out.println(x.intern() == s3.intern());  // true
```



变量x为两个String类型的对象相加，因为`x != s3`，所以x肯定不是指向的字符串常量，实际上x就是一个String类型的对象，调用`x.intern()`方法将返回"11"对应的字符串常量，所以`x.intern() == s3.intern()`为true。



## Rampage

将上面的代码简化并添加几个变量如下：



```
String x = new String("1") + new String("1");
String x1 = new String("1") + "1";
String x2 = "1" + "1";
String s3 = "11";

System.out.println(x == s3);  // false
System.out.println(x1 == s3);  // false
System.out.println(x2 == s3); // true
```



`x == s3`为false表示x指向String类型对象，s3指向字符串常量;

`x1 == s3`为false表示x1指向String类型对象，s3指向字符串常量;

`x2 == s3`为true表示x2指向字符串常量，s3指向字符串常量;



所以我们可以看到`new String("1") + "1"`返回的String类型的对象。

## 总结

现在我们知道intern方法就是将字符串保存到常量池中，在保存字符串到常量池的过程中会先查看常量池中是否已经存在相等的字符串，如果存在则直接使用该字符串。

所以我们在写业务代码的时候，应该尽量使用字符串常量池中的字符串，比如使用`String s = "1";`比使用`new String("1");`更节省内存。

我们也可以使用`String s  = 一个String类型的对象.intern();`方法来间接的使用字符串常量，这种做法通常用在你接收到一个String类型的对象而又想节省内存的情况下，当然你完全可以String s  = 一个String类型的对象;但是这么用可能会因为变量s的引用而影响String类型对象的垃圾回收。

所以我们可以使用intern方法进行优化，但是需要注意的是`intern`能节省内存，但是会影响运行速度，因为该方法需要去常量池中查询是否存在某字符串。

参考：https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html 